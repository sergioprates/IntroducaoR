---
title: "Programando IA com R"
output: html_notebook
---


#### Portfólio

### Conceitos de variáveis


**Vetor**

Toda variável no R é um vetor, um vetor pode visto como um conjunto de valores linear e homogêneo.

Para atribuir um valor à uma variável, utilizamos a seta <- indicando para onde estamos direcionando o valor.

É importante saber também, que para criar um vetor com valores, podemos utilizar a função c() que combina os valores em um vetor

Sendo assim, abaixo estamos criando a variável vetor e atribuindo o valor 1 5 4

```{r}
vetor <- c(1, 5, 4)

vetor
```


### Tipos de valores

**Numéricos e Caracteres**


No R tempos o conceito de tipos, onde cada valor tem um tipo específico, lembra das aulas de matemática sobre inteiros, decimais, etc?

Para verificar o tipo interpretado pelo R de um valor, podemos utilizar a função class(valor), onde valor é igual ao valor que você quer verificar.

```{r}
class(5)
class("Olá mundo")
```


**Reconhecendo tipos de variáveis**

Veja que o R reconheceu o valor 5 como númerico e o texto "Olá mundo" como um conjunto de caracteres.

Isto também se aplica a variáveis, veja só:

```{r}
variavel_numerica <- c(1,5,4,7)
variavel_caracteres <- c("Olá mundo")

class(variavel_numerica)
class(variavel_caracteres)
```


Também podemos usar as funções disponíveis em "is" para verificar os tipos, essa verificação retorna um tipo lógico para nós
```{r}
variavel <- "5"
is.numeric(variavel)
is.character(variavel)
```



**Lógicos**

No R, também é possível criar tipos lógicos (verdadeiro ou falso)

```{r}
logicos <- c(TRUE, FALSE, TRUE)
logicos2 <- c(T, F, T)

logicos
logicos2

class(logicos)
```


Veja que é possível abreviar as declarações. 

**Inteiros Explicitos**

Você deve ter percebido que no caso do tipo numérico, o tipo não foi declarado explicitamente como inteiro, para fazer isso veja o próximo trecho:

```{r}
inteiros <- c(1L, 2L, 3L)

inteiros
class(inteiros)
```


### Gerando sequências

Gerar sequências no R é uma coisa muito fácil e divertida! Temos algumas formas para  fazer isso:

```{r}
#Gerando números de 1 a 10
1:10

#Gerando números de 10 a 1
10:1

#Gerando números de 100 a 120

seq(100, 120)

#Gerando 10 números a partir de 100

seq(100, length.out = 10)

#Gerando números de 10 a 20 de 2 em 2

seq.int(from = 10, to = 20, by = 2)

#Gerando 20 números

seq_len(20)

#Gerando um vetor do mesmo tamanho que o vetor passado

seq_along(c(70, 2))

#Repetindo o número 4 5 vezes

rep(4, times = 5)

```

**NA, NaN, Inf, -Inf e NULL**

Os tipos especiais são valores que possuem uma característica bem específica.

NA = Não disponível (Not Available)
NaN = Não númerico (Not A Number)
Inf = Infinito
-Inf = -Infinito
NULL = Vazio

Perceba que NA possui um tipo, mas NULL não, NULL representa o nada no caso do R e de diversas linguagens de programação.

Um detalhe é que não é possível colocar NULL em um vetor, ou seja, caso criemos um vetor com NULL, o R remove ele automáticamente

```{r}
valor.na <- NA
valor.null <- NULL
valor.infinito <- Inf;
valor.menos.infinito <- -Inf
valor.nan <- NaN

vetor.com.null <- c(10,10,10,NULL)

vetor.com.null
```


### Operações aritméticas

No R é possível fazer operações aritméticas entre os valores disponíveis, abaixo teremos exemplos para algumas operações aritméticas simples:
```{r}

# Adição
adicao <- 5+5
adicao

# Subtração
subtracao <- 5-5
subtracao

# Multiplicação
multiplicao <- 5*5
multiplicao

# Divisão
divisao <- 5/5
divisao

#Raiz Quadrada

raiz <- sqrt(10)
raiz

#Numero imaginário
numero <- 1i
numero
```

**Operações com vetores**

As operações aritméticas se estendem a vetores também, veja abaixo um exemplo:

```{r}
# Vetor de dez posições
vetor <- c(1:10)

vetor * 2

# Veja que obtemos o dobro de cada valor do vetor, isso se aplica para todas as operações.

```



### Tipos avançados

**Fatores**

Através de fatores, é possível classificar dados para que as máquinas consigam processar com mais facilidade. Veja que no output, o R escreve "Levels: Feminino Masculino" para identificar as classes encontradas.
```{r}
sexo <- c("Feminino", "Masculino","Feminino", "Masculino","Feminino", "Masculino","Feminino", "Masculino","Feminino", "Masculino")

fatorado <- as.factor(sexo);

fatorado
```


**Listas**

No R, temos o tipo de lista onde é possível armazenar vetores com tipos diferentes:
```{r}

v1 <- c(1, 2, 3);
v2 <- c(T, F, T);
v3 <- c("a", "b", "c");
lista <- list(v1, v2, v3)

class(lista)

lista
```



**Matrizes**

Matrizes são um conjunto de valores distribuídos em linhas e colunas. A visualização abaixo deve esclarecer melhor:
```{r}
matriz <- matrix(ncol = 5, nrow = 5, data = 1:5)

matriz
```

Você deve ter percebido que também é possível atribuir uma matriz para uma variável com esse exemplo.

Vamos a um exemplo de operação com matrizes
```{r}
matrizA <- matrix(ncol = 5, nrow = 5, data = 1:5)
matrizB <- matrix(ncol = 5, nrow = 5, data = 1:5)

# Esta operação abaixo não é uma multiplicação de matrizes, é apenas uma multiplicação de valores.
matriz <- matrizA * matrizB

matriz
```

Para fazermos uma multiplicaçáo de matrizes, precisamos seguir uma regra: a quantidade de colunas da matriz A deve ser equivalente a quantidade de linhas da matriz B.

Abaixo um exemplo de multiplicação de matrizes:
```{r}
linhas <- 5
colunas <- 10

matrizA <- matrix(ncol = linhas, nrow = colunas, data = 1:2)
matrizB <- matrix(ncol = colunas, nrow = linhas, data = 1:2)

matrizA %*% matrizB
```


**Funções úteis para matrizes**

```{r}
matrizA <- matrix(ncol = 2, nrow = 2, data = 1:4)

print("Dimensões da matriz - Linhas x Colunas")
dim(matrizA)  #inversa, esta deve ser quadrada

print("Transposta")
t(matrizA) #transposta

print("Identidade")
diag(matrizA) #identidade

print("Inversa")
solve(matrizA)  #inversa, esta deve ser quadrada

matrizA <- cbind(matrizA, c(5,2)) #Adiciona colunas no fim da matriz

#Colunas adicionadas
print("Colunas adicionadas")
matrizA

print("Linhas adicionadas")
matrizA <- rbind(matrizA, c(5,2, 3))
matrizA
```


**Data Frame**

Criar um dataframe é bem simples, veja:
```{r}

vetorA <- c(1,5,4,7)
vetorB <- c("Olá mundo")

dataframe <- data.frame(vetorA, vetorB)

# Colocando nomes nas colunas

colnames(dataframe) <- c("Numérico", "Texto")

dataframe
```

O mais legal do dataframe, é que conseguimos colocar dados heterogêneos, ao contrário dos vetores e matrizes.

Também é possível criar um dataframe a partir de uma lista:
```{r}
lista <- list(c(1,2), c(T,F), c("teste", "teste2"))

dataframe <- data.frame(lista)

dataframe
```


**Datas**

Geralmente o trabalho com datas é uma das coisas mais complexas em programação. Vamos ver aqui algumas funções que o R disponibiliza para nós:
```{r}
data.texto = "13/11/2018 T 19:10:00"
data.date = as.Date(data.texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
data.time1 = as.POSIXct(data.texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
data.time2 = as.POSIXlt(data.texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
data.time1
data.time2
data.date 
```

Através do método unclass, podemos ver o conteúdo real de uma variável, suas propriedades e etc.
Quando passamos data.date para a função unclass, obtemos a quantidade de dias desde 01/01/1970 até a data da variável.

```{r}
unclass(data.date)
```


No caso de time1 e time2 veja que não temos diferenças no texto, entretanto veja quando fazemos o unclass.
```{r}
print("Time1")
unclass(data.time1)

print("Time2")
unclass(data.time2)
```

O unclass no time1 retorna a contagem em segundos desde 01/01/1970 até a data da variável!!


Para obter a data atual
```{r}
Sys.Date()
```



**Lubridate**

Lubridate é um pacote disponibilizado para manipular datas no R.
Para instalar e carregar:
```{r}
install.packages("lubridate")
library(lubridate)
```


O lubridate fornece funções que retornarão a data no formato solicitado e além disso ele trabalha com o conceito de duração.
```{r}
segundos  = dseconds(260)
minutos  = dminutes(260)
anos  = dyears(260)

duration(10, units = "seconds")

segundos
minutos
anos

#abaixo as funções de data

#Ano mes dia
data <- ymd("20190101")

# Dia mes ano hora
dmy_h("1110201810")

# Retorna o dia da semana
wday(data, label = T)

```



### Estruturas de controle

Para tomar algumas decisões durante a execução de código, o R fornece algumas estruturas de controle.

```{r}

souBonito <- TRUE

if (souBonito) {
  print("Eu Sei")
} else {
  print("Vish")
}

souBonito <- F
ifelse(souBonito, "verdade", "falso")

```

Estruturas de controle são muito úteis quando você precisa testar algum tipo de condição, se alguma compra foi realizada por exemplo, ou se algo ocorreu.

### Estruturas de repetição = loops


Loops são utilizados quando precisamos por exemplo repetir um conjunto de instruções para determinados itens.
```{r}
itens <- c(10,20,30)

for (variable in itens) {
  print(variable)
}
```

Veja que escrevemos todos os itens do vetor na tela, podemos utilizar para consolidar informações e enfim, para qualquer conjunto de instruções que precise se repetir.

Vamos montar um dataframe com um loop

```{r}
vetor <- 1:10
acumulado <- 0
tabela <- data.frame();
for (variable in vetor) {
  acumulado <- variable + acumulado
   tabela <- rbind(tabela, c(variable, acumulado))
}

colnames(tabela) <- c("Valor1", "Acumulado")
tabela

```




### Funções

Funções são utilizadas quando queremos reaproveitar algum trecho de código específico. por exemplo, digamos que precisamos calcular o enesimo termo de uma Progressão Aritmética

```{r}

primeiro.termo <- 1
razao <- 2

obter.termo.pa <- function(primeiro.termo, numero.termo, razao) {
  return(primeiro.termo + (numero.termo - 1) * razao)
}

obter.termo.pa(primeiro.termo, 50, razao)
```

Em funções, podemos receber reticências como parametro, que significa que podemos receber N parametros na função. Um exemplo de função assim é a função paste.
```{r}

concatena <- function(...) {
  c <- paste(...)
  c
}

concatena("Sergio", "Prates")
```



### Amostras

No R possuimos a função sample para randomizar a ocorrência de determinados valores
```{r}

# Letras de a até g
amostra1 <- letters[1:7]

# Letras de A até D
amostra2 <- LETTERS[1:4]

# Pode repetir as ocorrências
sample(x = amostra1, size = 20, replace = T)

# Não pode repetir as ocorrências
sample(x = amostra2, size = 3,  replace = F)
```

Para garantir que sempre o mesmo resultado aconteça, podemos utilizar a função set.seed com um valor fixo
```{r}
set.seed(1)
sample(x = amostra1, size = 20, replace = T)
```



### Simulações

O R nos fornecea alguns comandos para gerar dados aleatórios, sendo eles da família normal, binomial e uniforme.

Os comandos da familia normal possuem norm no final, os binomiais possuem binom e assim por diante...
Veja abaixo exemplos:

```{r}
set.seed(18) #garantindo que sempre sairá o mesmo resultado

# sd representa o desvio padrão dos dados

rnorm(n=10, mean=0, sd=1)

dnorm(x = 1:10, mean = 0, sd = 1)

pnorm( q = 1:10, mean = 0, sd = 1)

rbinom(size = 1:10, prob = c(0.1,0.1,0.1,0.1,0.1,0.1,1,1,1,1), n = 10)

dbinom(size = 1:10, prob = c(0.1,0.1,0.1,0.1,0.1,0.1,1,1,1,1), x = 1:10)

pbinom(q = 1:10, size = 1:10, prob = c(0.1,0.1,0.1,0.1,0.1,0.1,1,1,1,1))

rpois(100, 5)
```


### Plots básico

Para fazer plots, ou gráficos em R podemos utilizar a função plot()
```{r}
plot(x = cars$speed, y = cars$dist, type = "p", xlab = "Velocidade", ylab = "Distância", main = "Distância x Velocidade")
plot(x = cars$speed, y = cars$dist, type = "l", xlab = "Velocidade", ylab = "Distância", main = "Distância x Velocidade")

#Histogramas servem para analisar frequências
plot(x = cars$speed, y = cars$dist, type = "h", xlab = "Velocidade", ylab = "Distância", main = "Distância x Velocidade")


plot(x = cars$speed, y = cars$dist, type = "b", xlab = "Velocidade", ylab = "Distância", main = "Distância x Velocidade")

plot(x = cars$speed, y = cars$dist, type = "o", xlab = "Velocidade", ylab = "Distância", main = "Distância x Velocidade")

plot(x = cars$speed, y = cars$dist, type = "s", xlab = "Velocidade", ylab = "Distância", main = "Distância x Velocidade")

#Analisar correlação
#Tendencia
#Distribuição

#Box plot é um summary em gráficos

boxplot(airquality)

boxplot(airquality$Ozone, outline = F)
```

### Usando outra biblioteca...

Podemos utilizar a equação abaixo para plotar um gráfico linear
$y = \beta_0 + \beta_1 + \epsilon$

Onde

$\beta_0 = 0,5$

$\beta_1 = 2,0$

$x\sim N(0;1²)$

$\epsilon\sim N(0;2²)$

```{r}
install.packages('plotly')
library(plotly)

set.seed(5)
x = rnorm(n=350, mean=0, sd=1)
e = rnorm(n=350, mean=0, sd=2)
y=0.5 + 2*x + e

plot(x=x, y=y)

plot_ly(x=x, y=y, type="scatter", mode="markers")
```



### Gerando gráfico com pontos e linhas

```{r}
airquality %>% filter(Month == 5 & !is.na(Ozone)) %>% arrange(Ozone) %>% select(Ozonio = Ozone) -> ozonio


ozonio %>% summary() %>% as.list() -> valores

plot(ozonio$Ozonio)


minimo <- min(teste$Ozonio)
maximo <- max(teste$Ozonio)
media <- mean(teste$Ozonio)
mediana <- median(teste$Ozonio)
quartil <- quantile(teste$Ozonio)


lines(c(0, 30), c(minimo, minimo), col = 'blue')
lines(c(0, 30), c(maximo, maximo), col = 'blue')
lines(c(0, 30), c(media, media), col = 'blue')
lines(c(0, 30), c(mediana, mediana), col = 'red')
lines(c(0, 30), c(11.00, 11.00), col = 'blue')
```


### Baixando dados externos

Com a função download file podemos baixar arquivos da web, neste caso ele sempre trata como texto os dados.


```{r}

baixar <- function(url) {
  
  #Cria a pasta caso não exista
  
  if(!file.exists('data')){
    dir.create('data')
  }
  
  file.url = url
  file.local = file.path('./data', basename(file.url))
  download.file(url = file.url, destfile = file.local , mode='wb')
}

baixar('https://raw.githubusercontent.com/elthonf/fiap-mba-r/master/data/Copas.csv')
baixar('https://raw.githubusercontent.com/elthonf/fiap-mba-r/master/data/Copas-Partidas.csv')
baixar('https://raw.githubusercontent.com/elthonf/fiap-mba-r/master/data/Copas-Jogadores.csv')
baixar('https://github.com/elthonf/fiap-mba-r/raw/master/data/cameras.baltimore.xlsx')

```

### Lendo dados de csv's

Para ler dados de csvs podemos utilizar a função read.csv


```{r}
copas <- read.csv('./data/Copas.csv', header = T)
copas
```

Para ler dados do excel, podemos utilizar o pacote 

```{r}
install.packages('readxl')
library(readxl)

df.cameras <- read_xlsx('./data/cameras.baltimore.xlsx')

head(df.cameras)
```


### Manipulando estruturas de tabelas com dplyr

O pacote dplyr nos ajuda a manipular estruturas de tabelas de maneira bastante eficiente.

Abaixo utilizamos o pipe para passar o conteúdo 

```{r}
install.packages('dplyr')
library(dplyr)

BrFlights2 %>%
mutate(Partida.Atraso = (Partida.Real - Partida.Prevista)) %>% 
mutate(Chegada.Atraso = (Chegada.Real - Chegada.Prevista)) %>% 
mutate(Distancia = (sqrt((LatOrig - LatDest)^2 + (LongOrig - LongDest)^2))) %>% 
mutate(TempoViagem.Real = (Chegada.Real - Partida.Real)) -> tabela

tabela
```

### Visualizando gráficos lado a lado

```{r}

#exibir duas linhas e duas colunas

par(mfrow=c(2,2))

boxplot(airquality$Ozone~airquality$Solar.R)
boxplot(airquality$Ozone~airquality$Wind)
hist(airquality$Ozone)
hist(airquality$Wind)

```



### Clusterizando dados, identificando proximidades

```{r}
set.seed(1909)

x <- rnorm(15, mean = rep(1:3, each = 5), sd = 0.2)
y <- rnorm(15, mean = rep(c(1,2), each = 5), 0.2)
plot(x, y, col = 'blue', pch = 8, cex = 1)
text(x + 0.05, y + 0.05, labels = as.character(1:15))

df <- data.frame(x, y)

nclusters <- 3
modelo <- kmeans(x = df, centers = nclusters, iter.max = 5)


plot(x,y,col= modelo$cluster, pch = 19, cex=2);

points(modelo$centers, col=1:nclusters, pch = 3, cex=3, lwd = 2)
```


### Clusterizando 3 dimensões

```{r}
set.seed(1909)

velocidade <- rnorm(15, mean = rep(1:3, each = 5), sd = 0.2)
vento <- rnorm(15, mean = rep(c(1,2), each = 5), 0.2)
altura <- rnorm(15, mean = rep(c(1,2), each = 5), 0.2)

df <- data.frame(velocidade, vento, altura)

nclusters <- 4
modelo <- kmeans(x = df, centers = nclusters, iter.max = 5)


plot(df,col= modelo$cluster, pch = 19, cex=2);

#Pontos apenas funciona em plot único.
points(modelo$centers, col=1:nclusters, pch = 3, cex=3, lwd = 2)
```

